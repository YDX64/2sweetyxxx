name: Continuous Backup

on:
  push:
    branches: [ main ]
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Type of backup to create'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - incremental
          - code-only
          - database-only

env:
  BACKUP_RETENTION_DAYS: 30

jobs:
  create-backup:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Get timestamp
        id: timestamp
        run: echo "timestamp=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
      
      - name: Get version
        id: version
        run: |
          # Extract version from package.json or use commit hash
          if [ -f package.json ]; then
            VERSION=$(node -p "require('./package.json').version || '0.0.0'")
          else
            VERSION="0.0.0"
          fi
          echo "version=${VERSION}-${{ steps.timestamp.outputs.timestamp }}" >> $GITHUB_OUTPUT
      
      - name: Create backup archive
        run: |
          # Create backup directory
          mkdir -p backups
          
          # Define backup name
          BACKUP_NAME="2sweety-backup-${{ steps.version.outputs.version }}"
          
          # Create comprehensive backup based on type
          if [ "${{ github.event.inputs.backup_type }}" == "database-only" ]; then
            # Database schema only
            tar -czf "backups/${BACKUP_NAME}-db.tar.gz" \
              --exclude=node_modules \
              --exclude=.git \
              supabase/migrations \
              shared/schema.ts \
              drizzle.config.ts
          elif [ "${{ github.event.inputs.backup_type }}" == "code-only" ]; then
            # Code without dependencies
            tar -czf "backups/${BACKUP_NAME}-code.tar.gz" \
              --exclude=node_modules \
              --exclude=.git \
              --exclude=dist \
              --exclude=build \
              --exclude=.env* \
              --exclude=uploads \
              .
          else
            # Full backup
            tar -czf "backups/${BACKUP_NAME}-full.tar.gz" \
              --exclude=node_modules \
              --exclude=.git \
              --exclude=dist \
              --exclude=build \
              --exclude=.env \
              --exclude=uploads \
              .
          fi
          
          # Create metadata file
          cat > "backups/${BACKUP_NAME}-metadata.json" << EOF
          {
            "version": "${{ steps.version.outputs.version }}",
            "timestamp": "${{ steps.timestamp.outputs.timestamp }}",
            "backup_type": "${{ github.event.inputs.backup_type || 'full' }}",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "branch": "${{ github.ref_name }}",
            "triggered_by": "${{ github.event_name }}",
            "files_count": $(find . -type f -not -path "./node_modules/*" -not -path "./.git/*" | wc -l),
            "total_size": "$(du -sh . --exclude=node_modules --exclude=.git | cut -f1)"
          }
          EOF
      
      - name: Create release notes
        run: |
          cat > release-notes.md << EOF
          # Backup: ${{ steps.version.outputs.version }}
          
          ## Backup Information
          - **Type**: ${{ github.event.inputs.backup_type || 'full' }}
          - **Date**: ${{ steps.timestamp.outputs.timestamp }}
          - **Commit**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **Triggered by**: ${{ github.event_name }}
          
          ## Recent Changes
          $(git log --oneline -10)
          
          ## Restoration Instructions
          1. Download the backup archive
          2. Extract: \`tar -xzf backup-file.tar.gz\`
          3. Follow the restoration guide in DISASTER_RECOVERY.md
          
          ## Backup Contents
          - Full source code (excluding node_modules)
          - Database migrations and schema
          - Configuration files (excluding .env)
          - Documentation
          EOF
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: backup-${{ steps.version.outputs.version }}
          name: Backup ${{ steps.version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: true
          files: |
            backups/*
      
      - name: Upload to artifacts (short-term storage)
        uses: actions/upload-artifact@v4
        with:
          name: backup-${{ steps.version.outputs.version }}
          path: backups/
          retention-days: 7
      
      - name: Cleanup old releases
        uses: dev-drprasad/delete-older-releases@v0.3.2
        with:
          keep_latest: 30
          delete_tag_pattern: backup-
          delete_tags: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Send notification
        if: always()
        run: |
          # Send webhook notification or email about backup status
          echo "Backup ${{ job.status }}: ${{ steps.version.outputs.version }}"
          # Add your notification logic here (Discord, Slack, email, etc.)

  verify-backup:
    needs: create-backup
    runs-on: ubuntu-latest
    
    steps:
      - name: Download backup artifact
        uses: actions/download-artifact@v4
        with:
          pattern: backup-*
      
      - name: Verify backup integrity
        run: |
          # Check if backup files exist
          for file in backup-*/*.tar.gz; do
            if [ -f "$file" ]; then
              echo "Verifying $file..."
              tar -tzf "$file" > /dev/null && echo "✓ $file is valid" || echo "✗ $file is corrupted"
            fi
          done
      
      - name: Report verification status
        run: |
          echo "Backup verification completed"
          # Add detailed reporting logic here